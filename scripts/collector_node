#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Standart, System and Third party
import sqlalchemy as db
from sqlalchemy.sql import func
from datetime import datetime
import json

from http.client import HTTPSConnection
from threading import Timer

# ROS
import rospy

from collector_agent.srv import PublishDemand, PublishDemandRequest


class CollectorNode:

    def __init__(self):
        rospy.init_node('collector')
        rospy.loginfo('Launching collector node...')

        rospy.wait_for_service("/applicant/publish_demand")
        self.publish_service = rospy.ServiceProxy("/applicant/publish_demand", PublishDemand)

        # Init DB
        engine = db.create_engine(rospy.get_param('~db_url')[:-1])
        self.connection = engine.connect()
        self.solar = self.__init_table(engine, rospy.get_param('~table_name'))

        self.rest_api_key = rospy.get_param('~rest_api_key')[:-1]
        self.request_interval = 24*60*60      # seconds between requests
        self.server = "api.enorchile.cl"
        self.get_request = "/v1.0/meters?sourceid=9&quantityid=129&month={}&year={}"

        rospy.loginfo('Collector node is ready!')

        rospy.loginfo("Interval between requests is {} hours".format(int(self.request_interval / 60 / 60)))

    @staticmethod
    def __init_table(engine, table_name):
        metadata = db.MetaData()
        if not engine.dialect.has_table(engine, table_name):
            rospy.loginfo("Initialazing DB with a table name '{}'".format(table_name))

            solar = db.Table(table_name, metadata,
                             db.Column('id', db.Integer, primary_key=True),
                             db.Column('measure', db.TEXT),
                             db.Column('time_stamp', db.TIMESTAMP(True), server_default=func.now()))
            metadata.create_all(engine)
            return solar
        return db.Table(table_name, metadata, autoload=True, autoload_with=engine)

    def spin(self):
        def collect_data():
            c = HTTPSConnection(self.server)
            headers = {'X-API-Key': self.rest_api_key}

            # Quering the last row
            sel = self.solar.select().order_by(db.desc("id")).limit(1)
            last_row = self.connection.execute(sel).fetchone()
            last_date = last_row[2]

            today = datetime.today()
            if (today - last_date).total_seconds() > self.request_interval:
                rospy.loginfo("More than {} seconds have passed since last request".format(self.request_interval))
                rospy.loginfo("Requesting new data...")
                try:
                    c.request('GET', self.get_request.format(today.month, today.year), headers=headers)
                    # get the response back
                    res = c.getresponse()

                    if res.status == 200:
                        # at this point you could check the status etc
                        # this gets the page text
                        data = res.read().decode("utf-8")

                        data_dict = json.loads(data)
                        res_measure = str(data_dict["data"][-1]["value"])
                        res_timeutc = str(data_dict["data"][-1]["timeutc"])

                        rospy.loginfo("Received response: {} kW at {}".format(res_measure, res_timeutc))

                        sel = self.solar.select().order_by(db.desc("id")).limit(1)
                        last_row = self.connection.execute(sel).fetchone()
                        # rospy.loginfo("Last row in db: {}".format(last_row))

                        if not last_row:    # if db is empty insert first row
                            ins = db.insert(self.solar).values(measure=last_measure)
                            res = self.connection.execute(ins)
                        else:
                            measure = last_row[1]
                            # rospy.loginfo("Last measure from db: {}".format(measure))

                            if last_measure != measure:
                                ins = db.insert(self.solar).values(measure=last_measure)
                                self.connection.execute(ins)

                                delta = float(res_measure) - float(measure)
                                rospy.loginfo("Delta is {}".format(delta))

                                self.publish_service(PublishDemandRequest(str(delta)))

                except Exception as e:
                    rospy.logerr("[Collector] Got an error: {}. Retrying...".format(e))

            Timer(self.request_interval, collect_data).start()


        # Commented for test purpose
        collect_data()
        rospy.spin()


if __name__ == '__main__':
    CollectorNode().spin()
